#!/usr/bin/env ruby
# frozen_string_literal: true

# Script de vÃ©rification de la configuration LCL
# Usage: bin/check_lcl_config

require_relative '../config/environment'

puts "ğŸ” VÃ©rification de la configuration LCL/Sherlock\n\n"

# VÃ©rifier les variables d'environnement
puts "ğŸ“‹ Variables d'environnement:"
vars = {
  'LCL_MERCHANT_ID' => ENV['LCL_MERCHANT_ID'],
  'LCL_CERTIFICATE_PATH' => ENV['LCL_CERTIFICATE_PATH'],
  'LCL_PRIVATE_KEY_PATH' => ENV['LCL_PRIVATE_KEY_PATH'],
  'BASE_URL' => ENV['BASE_URL']
}

vars.each do |name, value|
  if value.present?
    puts "  âœ… #{name}: #{value.length > 30 ? value[0..30] + '...' : value}"
  else
    puts "  âŒ #{name}: NON DÃ‰FINIE"
  end
end

puts "\nğŸ“ Certificats:"

# VÃ©rifier les certificats
cert_path = ENV['LCL_CERTIFICATE_PATH']
key_path = ENV['LCL_PRIVATE_KEY_PATH']

if cert_path.present? && File.exist?(cert_path)
  puts "  âœ… Certificat trouvÃ©: #{cert_path}"
  
  begin
    cert = OpenSSL::X509::Certificate.new(File.read(cert_path))
    puts "     Sujet: #{cert.subject}"
    puts "     ValiditÃ©: #{cert.not_before} - #{cert.not_after}"
    
    if cert.not_after < Time.now
      puts "     âš ï¸  CERTIFICAT EXPIRÃ‰!"
    elsif cert.not_after < 30.days.from_now
      puts "     âš ï¸  Certificat expire bientÃ´t: #{cert.not_after}"
    end
  rescue OpenSSL::X509::CertificateError => e
    puts "     âŒ Certificat invalide: #{e.message}"
  end
else
  puts "  âŒ Certificat introuvable: #{cert_path}"
end

if key_path.present? && File.exist?(key_path)
  puts "  âœ… ClÃ© privÃ©e trouvÃ©e: #{key_path}"
  
  begin
    key = OpenSSL::PKey::RSA.new(File.read(key_path))
    puts "     Taille de clÃ©: #{key.n.num_bits} bits"
  rescue OpenSSL::PKey::RSAError => e
    puts "     âŒ ClÃ© privÃ©e invalide: #{e.message}"
  end
else
  puts "  âŒ ClÃ© privÃ©e introuvable: #{key_path}"
end

# Tester le client LCL
puts "\nğŸ”Œ Client LCL:"

begin
  client = Lcl.client
  
  if client.configured?
    puts "  âœ… Client configurÃ©"
    puts "     Merchant ID: #{client.merchant_id}"
    puts "     Base URL: #{client.base_url}"
    
    # Tester la signature
    begin
      test_params = { test: 'data', amount: 1000 }
      signature = client.signature.generate(test_params)
      puts "  âœ… Signature gÃ©nÃ©rÃ©e avec succÃ¨s"
      puts "     Test signature: #{signature[0..30]}..."
      
      # VÃ©rifier la signature
      if client.signature.verify(test_params, signature)
        puts "  âœ… VÃ©rification de signature OK"
      else
        puts "  âŒ VÃ©rification de signature Ã‰CHOUÃ‰E"
      end
    rescue StandardError => e
      puts "  âŒ Erreur lors de la gÃ©nÃ©ration de signature: #{e.message}"
    end
  else
    puts "  âŒ Client non configurÃ©"
  end
rescue Lcl::Client::ConfigurationError => e
  puts "  âŒ Erreur de configuration: #{e.message}"
rescue StandardError => e
  puts "  âŒ Erreur inattendue: #{e.message}"
  puts "     #{e.backtrace.first(3).join("\n     ")}"
end

# RÃ©sumÃ©
puts "\n" + "=" * 60
puts "ğŸ“Š RÃ‰SUMÃ‰\n\n"

if vars.values.all?(&:present?) && 
   File.exist?(cert_path.to_s) && 
   File.exist?(key_path.to_s) &&
   Lcl.client.configured?
  puts "âœ… Configuration LCL complÃ¨te et fonctionnelle!"
  puts "\nğŸ’¡ Vous pouvez maintenant:"
  puts "   - Tester un paiement en dÃ©veloppement"
  puts "   - DÃ©ployer en production avec les bons certificats"
else
  puts "âŒ Configuration incomplÃ¨te. Veuillez:"
  puts "   1. CrÃ©er un fichier .env (voir .env.example)"
  puts "   2. Placer vos certificats dans config/certificates/"
  puts "   3. Relancer ce script pour vÃ©rifier"
  puts "\nğŸ“– Voir CHANGEMENTS_PAIEMENT.md et lib/lcl/MIGRATION.md"
end

puts "=" * 60

